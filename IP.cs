using System;

/**
<summary>Encapsulates an IP Packet and can create new IP Packets.</summary>
<remarks>
The packet consists of these fields:
<list type="table">
<listheader>
<term>Field</term>
<description>Description</description>
</listheader>
<item>
<term>Version</term>
<description>4 bits - Format =  4 - IP Protocol</description>
</item>
<item>
<term>IHL</term>
<description>4 bits - Length of IP Header in 32-bit words = 5</description>
</item>
<item>
<term>TOS</term>
<description>8 bits - Type of service = 0 - routine</description>
</item>
<item>
<term>Total Length</term>
<description>16 bits</description>
</item>
<item>
<term>ID</term>
<description>16 bits - no fragmenting unnecessary</description>
</item>
<item>
<term>Flags</term>
<description>3 bits - no fragmenting unnecessary</description>
</item>
<item>
<term>Fragment offset</term>
<description>13 - no fragmenting unnecessary</description>
</item>
<item>
<term>TTL</term>
<description>8 bits - 64 seems reasonable if not absurd!</description>
</item>
<item>
<term>Protocol</term>
<description>8 bits - udp / tcp / icmp/ igmp</description>
</item>
<item>
<term>Header Checksum</term>
<description>16 - one's complement checksum of the ip header and ip 
options</description>
</item>
<item>
<term>Source IP</term>
<description>32 bits</description>
</item>
<item>
<term>Destination IP</term>
<description>32 bits</description>
</item>
<item>
<term>Data</term>
<description>Rest</description>
</item>
</list>
</remarks>
*/
public class IPPacket : NetworkPacket
{
    /// <summary>The zero address</summary>
    public static readonly MemBlock ZeroAddress = MemBlock.Reference(
      new byte[] { 0, 0, 0, 0 });
    /// <summary>The default broadcast (multicast) address</summary>
    public static readonly MemBlock BroadcastAddress = MemBlock.Reference(
      new byte[] { 0xFF, 0xFF, 0xFF, 0xFF });
    /// <summary>The IP Address where the packet originated</summary>
    public readonly MemBlock SourceIP;
    /// <summary>The IP Address where the packet is going</summary>
    public readonly MemBlock DestinationIP;

    /// <summary>Created only if SSourceIP is accessed, contains the string
    /// representation of the Source IP</summary>
    private string _sourceip;
    /// <summary>Contains the string representation of the Source IP</summary>
    public string SSourceIP
    {
        get
        {
            if (_sourceip == null)
            {
                _sourceip = SourceIP[0] + "." + SourceIP[1] + "." + SourceIP[2] + "." + SourceIP[3];
            }
            return _sourceip;
        }
    }

    /// <summary>Created only if SDestinationIP is accessed, contains the
    /// string representation of the Source IP</summary>
    private string _destinationip;
    /// <summary>Contains the string representation of the Destination Ip</summary>
    public string SDestinationIP
    {
        get
        {
            if (_destinationip == null)
            {
                _destinationip = DestinationIP[0] + "." + DestinationIP[1] + "." +
                    DestinationIP[2] + "." + DestinationIP[3];
            }
            return _destinationip;
        }
    }

    /// <summary> Enumeration of Protocols used by Ipop.</summary>
    public enum Protocols
    {
        /// <summary> Internet Control Message Protocol.</summary>
        ICMP = 1,
        /// <summary>Internet Group Management Protocol.</summary>
        IGMP = 2,
        /// <summary>Transmission Control Protocol.</summary.
        TCP = 6,
        /// <summary>User Datagram Protocol.</summary>
        UDP = 17
    };
    /// <summary>The protocol for this packet.</summary>
    public readonly Protocols Protocol;

    /**
    <summary>Takes in a MemBlock and parses it into IP Header fields</summary>
    <param name="Packet">The IP Packet to parse.</param>
    */
    public IPPacket(MemBlock Packet)
    {
        _icpacket = _packet = Packet;
        Protocol = (Protocols)Packet[9];
        SourceIP = Packet.Slice(12, 4);
        DestinationIP = Packet.Slice(16, 4);
        _icpayload = _payload = Packet.Slice(20);
    }

    /**
    <summary>Takes in the IP Header fields and a payload to create an IP
    Packet.  Unlisted fields are generated by this constructor automatically.
    </summary>
    <param name="Protocol">The type of payload</param>
    <param name="SourceIP">The packets originating ip address</param>
    <param name="DestinationIP">The destination for the packet</param>
    <param name="Payload">The data stored in the IP Packet</param>
    */
    public IPPacket(Protocols Protocol, MemBlock SourceIP, MemBlock DestinationIP, ICopyable Payload)
    {
        byte[] header = new byte[20];
        // Version | IHL
        header[0] = (4 << 4) | 5;
        // Just a routine header!
        header[1] = 0;
        int length = header.Length + Payload.Length;
        header[2] = (byte)((length >> 8) & 0xFF);
        header[3] = (byte)(length & 0xFF);
        // Fragment crap
        header[4] = 0;
        header[5] = 0;
        header[6] = 0;
        header[7] = 0;
        // TTL
        header[8] = 64;
        header[9] = (byte)Protocol;
        for (int i = 0; i < 4; i++)
        {
            header[12 + i] = SourceIP[i];
            header[16 + i] = DestinationIP[i];
        }
        int checksum = GenerateChecksum(MemBlock.Reference(header));
        header[10] = (byte)((checksum >> 8) & 0xFF);
        header[11] = (byte)(checksum & 0xFF);

        MemBlock Header = MemBlock.Reference(header);
        _icpacket = new CopyList(Header, Payload);

        this.Protocol = Protocol;
        this.SourceIP = SourceIP;
        this.DestinationIP = DestinationIP;
        _icpayload = Payload;
    }


    /**
    <summary>Takes in the IP Header fields and a payload to create an IP
    Packet.  Unlisted fields are generated by this constructor automatically.
    </summary>
    <param name="Protocol">The type of payload</param>
    <param name="SourceIP">The packets originating ip address</param>
    <param name="DestinationIP">The destination for the packet</param>
    <param name="hdr">The original header of the IPPacket</param>
    <param name="Payload">The data stored in the IP Packet</param>
    */
    public IPPacket(Protocols Protocol, MemBlock SourceIP, MemBlock DestinationIP, MemBlock hdr, ICopyable Payload)
    {
        byte[] header = new byte[20];
        // Version | IHL
        header[0] = hdr[0];
        // Just a routine header!
        header[1] = hdr[1];
        int length = header.Length + Payload.Length;
        header[2] = (byte)((length >> 8) & 0xFF);
        header[3] = (byte)(length & 0xFF);
        // Fragment crap
        header[4] = hdr[4];
        header[5] = hdr[5];
        header[6] = hdr[6];
        header[7] = hdr[7];
        // TTL
        header[8] = hdr[8];
        header[9] = hdr[9];
        for (int i = 0; i < 4; i++)
        {
            header[12 + i] = SourceIP[i];
            header[16 + i] = DestinationIP[i];
        }
        int checksum = GenerateChecksum(MemBlock.Reference(header));
        header[10] = (byte)((checksum >> 8) & 0xFF);
        header[11] = (byte)(checksum & 0xFF);

        MemBlock Header = MemBlock.Reference(header);
        _icpacket = new CopyList(Header, Payload);

        this.Protocol = Protocol;
        this.SourceIP = SourceIP;
        this.DestinationIP = DestinationIP;
        _icpayload = Payload;
    }

    /**
    <summary>If we're not creating a packet from scratch, this will keep its
    integrity and transform UDP and TCP headers as well (due to their checksums
    being dependent on source and destination ip addresses.</summary>
    <param name="Packet">The packet to translate.</param>
    <param name="SourceIP">The new source ip.</param>
    <param name="DestinationIP">The new destination ip.</param>
    */
    public static MemBlock Translate(MemBlock Packet, MemBlock SourceIP, MemBlock DestinationIP)
    {
        byte[] new_packet = new byte[Packet.Length];
        Packet.CopyTo(new_packet, 0);
        int length = (Packet[0] & 0xF) * 4;
        SourceIP.CopyTo(new_packet, 12);
        // Do not copy over multicast addresses!
        if (new_packet[16] < 224 || new_packet[16] > 239)
        {
            DestinationIP.CopyTo(new_packet, 16);
        }
        // Zero out the checksum so we don't use it in our future calculations
        new_packet[10] = 0;
        new_packet[11] = 0;
        MemBlock header = MemBlock.Reference(new_packet, 0, length);
        int checksum = GenerateChecksum(header);
        new_packet[10] = (byte)((checksum >> 8) & 0xFF);
        new_packet[11] = (byte)(checksum & 0xFF);
        Protocols p = (Protocols)Packet[9];

        bool fragment = ((Packet[6] & 0x1F) | Packet[7]) != 0;

        if (p == Protocols.UDP && !fragment)
        {
            // Zero out the checksum to disable it
            new_packet[length + 6] = 0;
            new_packet[length + 7] = 0;
        }
        else if (p == Protocols.TCP && !fragment)
        {
            // Zero out the checksum so we don't use it in our future calculations
            new_packet[length + 16] = 0;
            new_packet[length + 17] = 0;
            MemBlock payload = MemBlock.Reference(new_packet).Slice(length);
            MemBlock pseudoheader = IPPacket.MakePseudoHeader(SourceIP, DestinationIP, (byte)Protocols.TCP, Packet.Length - 20);
            checksum = IPPacket.GenerateChecksum(payload, pseudoheader);
            new_packet[length + 16] = (byte)((checksum >> 8) & 0xFF);
            new_packet[length + 17] = (byte)(checksum & 0xFF);
        }
        return MemBlock.Reference(new_packet);
    }

    /**
    <summary>Generates an 16-bit IP (UDP, TCP) checksum based upon header and
    optional extra memory blocks placed into args.</summary>
    <param name="header">The Header to base the checksum on.</param>
    <param name="args">Any extra memory blocks to include in checksum
    calculations.</param>
    <returns>a 16-bit IP header checksum.</returns>
    */
    public static int GenerateChecksum(MemBlock header, params Object[] args)
    {
        int value = 0;
        int length = header.Length;

        for (int i = 0; i < length; i += 2)
        {
            byte first = header[i];
            byte second = (length == i + 1) ? (byte)0 : header[i + 1];
            value += second + (first << 8);
        }

        for (int j = 0; j < args.Length; j++)
        {
            MemBlock tmp = (MemBlock)args[j];
            length = tmp.Length;
            for (int i = 0; i < length; i += 2)
            {
                byte first = tmp[i];
                byte second = (length == i + 1) ? (byte)0 : tmp[i + 1];
                value += second + (first << 8);
            }
        }

        while (value >> 16 > 0)
        {
            value = (value & 0xFFFF) + (value >> 16);
        }

        return ~value & 0xFFFF;
    }

    public static MemBlock MakePseudoHeader(MemBlock SourceIP, MemBlock DestinationIP, byte Protocol, int Length)
    {
        byte[] pseudoheader = new byte[12];
        SourceIP.CopyTo(pseudoheader, 0);
        DestinationIP.CopyTo(pseudoheader, 4);
        pseudoheader[9] = Protocol;
        pseudoheader[10] = (byte)((Length >> 8) & 0xFF);
        pseudoheader[11] = (byte)(Length & 0xFF);
        return MemBlock.Reference(pseudoheader);
    }
}
